---
layout: post
title: "Docker - производительность файловой системы"
date: 2017-05-15 01:31:02
image: '/assets/img/'
description:
main-class:
color:
tags:
    - dev
categories:
twitter_text: "Docker - производительность файловой системы, пути решения"
introduction: "Докер, особенно на сложных системах контейнеров, на MacOs работает намного  медленнее, чем на нативном Linux, это факт"
---

### Проблема есть, она давно существует и давно описана.

Докер, особенно на сложных системах контейнеров, на MacOs работает намного  медленнее, чем на нативном Linux, это факт. Можно ознакомится с
бенчмарками, на вскидку Google выдает [1](http://www.cameronmaske.com/docker-on-osx/) [2](https://medium.freecodecamp.com/speed-up-file-access-in-docker-for-mac-fbeee65d0ee7)

Мониторю состояние проблемы я по вот [этой](https://github.com/docker/for-mac/issues/77) задаче на гитхабе.

Начиная с 17.04 CE Edge onwards появились новые флаги для выполнения **docker run -v** позволяющие управлять степенью синхронности 
примонтированного волума:

* consistent: полная согласованность. Контейнер и хост синхронны постоянно. Это значение по умолчанию. И на macOs это медленно, из за медленной работы osfx
* cached: файлы хоста для mount является авторитетным. Может быть задержка в переносе данных и обновлениях, сделанные на хосте, будут видны внутри контейнера через некоторое время. Используется для улучшения производительности чтения в контейнер с хост-машины. Детали реализации и настройки можно прочитать [тут](https://blog.docker.com/2017/05/user-guided-caching-in-docker-for-mac/)
* delegated: файлы контейнера для mount является авторитетным. Может быть задержка в переносе данных и обновлениях, сделанных в контейнере, до того как они будут видны на хосте. На текущий момент в 17.04 delegated ведет себя идентично consistent.

Команда Docker для Mac планирует выпустить улучшенную реализацию делегированных в будущем, чтобы ускорить работу с большими объемами записи.

На текущий момент есть два решения, в случае если :cached не решает вопроса:

* [d4m-nfs](https://github.com/IFSight/d4m-nfs)
* [docker-sync](http://docker-sync.io) и подобные решения, основаные на rsync/event based syncing (быстрая синхронизация, но нужно изменить настройки, и можно 
столкнуться с проблемами синхронизации)

Я пользовался вторым из решений, оно действительно быстрое(было до последнего обновления пару дней назад) - сейчас проблема в первом запуске при развертывании - первичное копирование с хост-машины внутрь контейнера проходит достаточно долго в приложении на symfony3
(связано с значительным объемом папки vendor)


